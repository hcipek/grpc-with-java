# **Project Grpc-Operations**

**Dependecies**

- This maven dependencies are required for this object;

  - io.grpc/grpc-netty-shaded
  - io.grpc/grpc-protobuf
  - io.grpc/grpc-stub
  - org.apache.tomcat/annotations-api
  - org.junit.jupiter/junit-jupiter-engine

#**Unary RPC**

**Service Definition**

- First, we are going to create a .proto file as usual.
- Second we are going to create our request and response messages.
- Third we are going to create the service with following syntax;
```
service ServiceName {
    rpc methodName(RequestObject) returns (ResponseObject);
}
```
- After that, we are going to run `mvn compile`
- When compile finished, you can see the generated classes under `target/generated-sources/protobuf/...`
- Example can be seen at bank-service.proto .

**Service Implementation**

- We have our service after mvn compile, but we need to implement that service to use. Because it has no logic inside.
- To do this, we create our own Service Class and extend the service generated by protoc.
- Service name will be ServiceNameGrpc.ServiceNameImplBase.
- Then we will override the method we created in proto file. 
- There is two parameters of this method, one is requestObject, other is responseObserver object. 
- ResponseObserver has three methods, `onNext`, `onCompleted` and `onError`.
- Example can be seen at BankService class.

**Server**

- This is basically the place that receiving actual calls and delivers them to service class.
- For creating Server, this code block is required;
  ```
    Server server = ServerBuilder.forPort(portNumber)
                .addService(new ServiceClass())
                .build();
  ```
- After creating server, we need to run it and make it run until termination.
  ```
    server.start(); //Throws IOException
    server.awaitTermination(); //Throws InterruptedException
  ```
- After everything is completed, we are run that code inside main method and our server is now available.
- Example can be seen at GrpcServer class.

**Testing Server and Blocking Stub**

- In BankClientTest, we are going to look at how to use our GrpcServer and BankService.
- First we are needed to create a ManagedChannel and use it for creating a newBlockingStub with generated BankServiceGrpc class;
  ```
    ManagedChannel managedChannel = ManagedChannelBuilder
                .forAddress("localhost", portNumber)
                .usePlaintext().build();

        this.bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(managedChannel);
  ```
- After that, we can use that blockingStub to call our service methods and see, how our service reacts to request.

**BloomRPC - A Tool for gRPC**

- BloomRPC is an application for gRPC calls. Like postman, we can use BloomRPC to call our services outside.
- Installation files can be found in : `https://github.com/bloomrpc/bloomrpc/releases`
- After installed it, open and click the button with a 'plus' sign, on the left top. It will want you to select your proto file and open a browse pop-up. Select your proto file and click OK.
- After you selected your service proto file, you can see its methods on left side of screen. 
- Click the method and change the address as which address that your server runs.
- Click the play button and see your response comes into screen.

**Testing with Node Client**

- This example is available under node-client folder of main project.
- First, create the folder and go inside, run `npm init -y` and after that install this library. `npm install @grpc/proto-loader grpc`
- Then we have copied our service.proto file under this package.
- The Java-Script file is responsible from the service call.(to test this, your server must be running)
- After finished with .js file, we can run the `node fileName.js` command and see the results.

#**Server Streaming RPC**

- Think Unary RPC, but this time, server sending stream of a responses, instead of a single response.
- When client doesn't require all the information/data at once, this kind of approach can be chosen.

**Service Definition**

- Similar to Unary requests, only difference is now our response object is a stream.

  `rpc method(Request) returns (stream Response);`
- Run `mvn compile` and it's ready to use.
- After the server-streaming method generated, we need to override that method inside our service.
- Another difference from Unary methods, we are going to call `StreamObserver.onNext()` method multiple times to create our stream.

**Validations and Error Handling**

- If our request requires some kind of validation and if that request is not valid, we are going to return some kind of error to inform the client.
- For this, we have our `StreamObserver.onError(Throwable throwable)` method. 
- To send some of RPC errors to the client, we are using `Status` class of `io.grpc` library.
  
  `Status status = Status.SOME_RPC_STATUS.withDescription(String desc);`
- After creating the Status object, we call the method named `.asRuntimeException()` to create our `Throwable` object.
- Now we can use this `Throwable` object in `onError()` method to show client an error with description when something is not valid.
- <a href=https://developers.google.com/maps-booking/reference/grpc-api-v2/status_codes>Link</a> for gRPC Error Codes.

**About Testing The Server Side Stream RPC**

- In Unary RPC part, we used blockingStub for calling our methods. It works in synchronous mode. 
- If we want an actual streaming response, we need an asynchronous response so, we are going to use the Stub(non-blocking).
- For that, we need two things;
  - Our Implementation of StreamObserver\<Entity>
  - A CountDownLatch object.
- Reason of implementation is, we need to tell our language to how we want to handle stream.
- CountDownLatch is helping us to understand when the stream ends. We create a CountDownLatch with count=1, so when an error comes or when the response ended, the count decreases and when count reaches 0 our thread will be finished.

#**Client Streaming RPC**

- This type of RPC is reverse version of Server-side streaming. Client send request in multiple parts, server returns one single response. 
- This could be useful when client doesn't know about how many times it requires to send a request but expecting a single response from them.
- For imagination, think it as a database insert/upsert operation. Client wants to upsert multiple entities, but wants response only when all of upsert operations are successful.
- But client also doesn't want to send all data at once, instead it is sending every entity one by one.
- Another example, think it as a war game, enemy army is attacking your castle, archers sends multiple arrows, each arrow reduce health of your castle (depend on critical rate, critical chance, castle defence reduce rate etc. every arrow reduce different damage even their base attack is same) and at the end you return total damage that your castle take to the player.

**Service Definition**

- As I said before, its reverse of Server-side streaming, so its proto method is following the same approach. Syntax can be seen below;
  `rpc method(stream request) returns (response);`
- We follow similar maven, override steps as I mentioned in server-side part.
- But this time, our logic will be inside of request object.

**Request Stream Observer Implementation**

- Another difference is we need to implement the request object. 
- Reason, because we need to tell our server to how to reach each element in stream.
- In `onNext` method, we will implement our logic.
- `onCompleted` method will be responsible for what we are going to return to our client.
- After implementation is finished, all we need to do is create an instance of the class we just created and return it in our new client-side stream method.

**About Testing The Client Side Stream RPC**

- As a client, we need to implement StreamObserver class to handle the response. 
- Since its client side streaming service call, service returns us a Streamable Request object and wants a Streamable response object as a parameter.
- So we are creating our Response Handler and define our actions in `onNext`, `onError` and `onCompleted` methods.
- Then, we are calling the service with our implemented Response object and service gives us a Streamable request object for sending our stream.
- Even though it looks and sounds complicated, it's best to accept it for what it is.

#**Bi-Directional RPC**

- 

**Service Definitions**