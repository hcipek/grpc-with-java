# **Project Unary-Operations**

**Dependecies**

- This maven dependencies are required for this object;

  - io.grpc/grpc-netty-shaded
  - io.grpc/grpc-protobuf
  - io.grpc/grpc-stub
  - org.apache.tomcat/annotations-api
  - org.junit.jupiter/junit-jupiter-engine

**Service Definition**

- First, we are going to create a .proto file as usual.
- Second we are going to create our request and response messages.
- Third we are going to create the service with following syntax;
```
service ServiceName {
    rpc methodName(RequestObject) returns (ResponseObject);
}
```
- After that, we are going to run `mvn compile`
- When compile finished, you can see the generated classes under `target/generated-sources/protobuf/...`
- Example can be seen at bank-service.proto .

**Service Implementation**

- We have our service after mvn compile, but we need to implement that service to use. Because it has no logic inside.
- To do this, we create our own Service Class and extend the service generated by protoc.
- Service name will be ServiceNameGrpc.ServiceNameImplBase.
- Then we will override the method we created in proto file. 
- There is two parameters of this method, one is requestObject, other is responseObserver object. 
- ResponseObserver has three methods, `onNext`, `onCompleted` and `onError`.
- Example can be seen at BankService class.

**Server**

- This is basically the place that receiving actual calls and delivers them to service class.
- For creating Server, this code block is required;
  ```
    Server server = ServerBuilder.forPort(portNumber)
                .addService(new ServiceClass())
                .build();
  ```
- After creating server, we need to run it and make it run until termination.
  ```
    server.start(); //Throws IOException
    server.awaitTermination(); //Throws InterruptedException
  ```
- After everything is completed, we are run that code inside main method and our server is now available.
- Example can be seen at GrpcServer class.

**Testing Server and Blocking Stub**

- In BankClientTest, we are going to look at how to use our GrpcServer and BankService.
- First we are needed to create a ManagedChannel and use it for creating a newBlockingStub with generated BankServiceGrpc class;
  ```
    ManagedChannel managedChannel = ManagedChannelBuilder
                .forAddress("localhost", portNumber)
                .usePlaintext().build();

        this.bankServiceBlockingStub = BankServiceGrpc.newBlockingStub(managedChannel);
  ```
- After that, we can use that blockingStub to call our service methods and see, how our service reacts to request.

**BloomRPC - A Tool for gRPC**

- BloomRPC is an application for gRPC calls. Like postman, we can use BloomRPC to call our services outside.
- Installation files can be found in : `https://github.com/bloomrpc/bloomrpc/releases`
- After installed it, open and click the button with a 'plus' sign, on the left top. It will want you to select your proto file and open a browse pop-up. Select your proto file and click OK.
- After you selected your service proto file, you can see its methods on left side of screen. 
- Click the method and change the address as which address that your server runs.
- Click the play button and see your response comes into screen.

**Testing with Node Client**

- This example is available under node-client folder of main project.
- First, create the folder and go inside, run `npm init -y` and after that install this library. `npm install @grpc/proto-loader grpc`
- Then we have copied our service.proto file under this package.
- The Java-Script file is responsible from the service call.(to test this, your server must be running)
- After finished with .js file, we can run the `node fileName.js` command and see the results.